Перед заголовком лежит его длина - 8 байт, в фотмате little-endian.
Заголовок в формате protobuf имеет следующие поля:

    1) algorithm - int64, алгоритм шифрования / расшифровки

    2) hash_function - int64, хе-функция, используемая для проверки пароля

    3) data_length - int64, длин полезных данных (для шифров, которые требуют блок данных определённой длины)

    4) users - список структур User, которые имеют следующие поля:
        key_salt - соль, используемая для генерации ключа с помощью kdf (key derivation function), присутствует в случае симметричного шифрования
        pw_salt - соль, используемая для генерации хеша, по которому проверяют пароль
        uid - в случае симметричного шифрования это hash_function(password + pw_salt)
              в случае гибридного шифрования это открытый ключ
        enkey - в случае симметричного шифрования это kdf(password + key_salt) ^ key
                в случае гибридного шифрования это симметричный ключ, зашифрованный на открытом ключе

В случае симметричного шифрования:
Ключ должен храниться в файле, и к нему нужно обеспечить доступ по паролю, но хранить в открытом виде ни ключ, ни пароль нельзя.
Поэтому нужно две хеш-функции, одна из которых (hash_function) будет вычислять хеш, используемый для проверки пароля, а вторая (kdf) - хеш, нужный для получения ключа. А чтобы пароль было труднее получить с помощью радужных таблиц, хешироваться будет не пароль, а солёный пароль - конкатенация пароля и соли (для каждой из двух функций соль будет своя).
Для вычисления ключа храниться в файле будет не ключ, а:
    1) hash_function(password + pw_salt)
    2) двоичная сумма ключа и kdf(password + key_salt)
Алгоритм получения ключа следующий:
    1) Пользователь вводит пароль, программа считает hash_function от него, сложенного с pw_salt.
    2) Если существует пользователь с таким полем, то пароль принимается как верный, от него, сложенного с key_salt, считается kdf
    3) kdf ^ enkey и есть ключ

В случае гибридного шифрования ключ симметричного алгоритма должен храниться в файле, и к нему нужно обеспечить доступ по закрытому ключу асимметричного шифра. Для этого ключ симметричного шифрования шифруется с помощью асиммметричного шифра открытым ключом, который также записывается в файл.

Для каждого алгоритма шифрования формат ключа свой, в нём могут быть закодированы несколько чисел, у него может быть своя длина, и т. д.
