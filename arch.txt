Перед заголовком лежит его длина - 8 байт.
Заголовок в формате protobuf имеет следующие поля:

    1) algorithm - int, алгоритм шифрования / расшифровки

    2) users_count - int, количество пользователей, которые могут расшифровать этот файл

    3) users - список структур, которые имеют следующие поля:
        hybrid - bool, показывает, использовалось ли гибридное шифрование
        salt - соль, присутствует в случае симметричного шифрования
        uid - в случае симметричного шифрования это hash(hash(password))
              в случае гибридного шифрования это открытый ключ
        enkey - в случае симметричного шифрования это hash(password) ^ key
                в случае гибридного шифрования это симметричный ключ, зашифрованный на открытом ключе

В случае симметричного шифрования ключ должен храниться в файле, и к нему нужно обеспечить доступ по паролю, но хранить в открытом виде ни ключ, ни пароль нельзя. Поэтому нужна хеш-функция, а чтобы пароль было труднее получить с помощью радужных таблиц, хешироваться будет не пароль, а солёный пароль - конкатенация пароля и соли. Храниться в файле будет не ключ, а двоичная сумма ключа и хеша от солёного пароля. При этом сам хеш в файле также хранить нельзя, иначе можно будет получить ключ. Поэтому в файле хранится не хеш от солёного пароля, а хеш от хеша от солёного пароля, чтобы можно было соотнести пароль и ключ.
В случае гибридного шифрования ключ симметричного алгоритма должен храниться в файле, и к нему нужно обеспечить доступ по закрытому ключу асимметричного шифра. Для этого ключ симметричного шифрования шифруется с помощью асиммметричного шифра открытым ключом, который также записывается в файл.

Для каждого алгоритма шифрования формат ключа свой, в нём могут быть закодированы несколько чисел, у него может быть своя длина, и т. д.

Эта сущность может быть сохранена в файле (в бинарном виде) и прочитана из файла
В случае симметричного шифрования может принять на вход пароль и определить, можно ли им расшифровать зашифрованный текст
В случае гибридного шифрования может принять закрытый ключ и определить, есть ли для него открытый ключ в файле
